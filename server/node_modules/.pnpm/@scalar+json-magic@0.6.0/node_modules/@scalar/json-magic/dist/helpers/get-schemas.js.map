{
  "version": 3,
  "sources": ["../../src/helpers/get-schemas.ts"],
  "sourcesContent": ["/**\n * Retrieves the $id property from the input object if it exists and is a string.\n *\n * @param input - The object to extract the $id from.\n * @returns The $id string if present, otherwise undefined.\n */\nexport const getId = (input: unknown): string | undefined => {\n  if (input && typeof input === 'object' && input['$id'] && typeof input['$id'] === 'string') {\n    return input['$id']\n  }\n  return undefined\n}\n\n/**\n * Joins an array of path segments into a single string separated by '/'.\n *\n * @param segments - The array of path segments.\n * @returns The joined path string.\n */\nconst getPath = (segments: string[]): string => {\n  return segments.join('/')\n}\n\n/**\n * Recursively traverses the input object to collect all schemas identified by $id and $anchor properties.\n *\n * - If an object has a $id property, it is added to the map with its $id as the key.\n * - If an object has a $anchor property, it is added to the map with a key composed of the current base and the anchor.\n * - The function performs a depth-first search (DFS) through all nested objects.\n *\n * @param input - The input object to traverse.\n * @param base - The current base URI, used for resolving anchors.\n * @param map - The map collecting found schemas.\n * @returns A map of schema identifiers to their corresponding objects.\n */\nexport const getSchemas = (\n  input: unknown,\n  base: string = '',\n  segments: string[] = [],\n  map = new Map<string, string>(),\n  visited = new WeakSet(),\n) => {\n  // Only process non-null objects\n  if (typeof input !== 'object' || input === null) {\n    return map\n  }\n\n  // If the object has already been visited, return the map\n  if (visited.has(input)) {\n    return map\n  }\n\n  // Add the object to the visited set\n  visited.add(input)\n\n  // Attempt to get $id from the current object\n  const id = getId(input)\n\n  // If $id exists, add the object to the map with $id as the key\n  if (id) {\n    map.set(id, getPath(segments))\n  }\n\n  // Update the base for nested anchors\n  const newBase = id ?? base\n\n  // If $anchor exists, add the object to the map with base#anchor as the key\n  if (input['$anchor'] && typeof input['$anchor'] === 'string') {\n    map.set(`${newBase}#${input['$anchor']}`, getPath(segments))\n  }\n\n  // Recursively traverse all properties (DFS)\n  for (const key in input) {\n    if (typeof input[key] === 'object' && input[key] !== null) {\n      getSchemas(input[key], newBase, [...segments, key], map, visited)\n    }\n  }\n\n  return map\n}\n"],
  "mappings": "AAMO,MAAM,QAAQ,CAAC,UAAuC;AAC3D,MAAI,SAAS,OAAO,UAAU,YAAY,MAAM,KAAK,KAAK,OAAO,MAAM,KAAK,MAAM,UAAU;AAC1F,WAAO,MAAM,KAAK;AAAA,EACpB;AACA,SAAO;AACT;AAQA,MAAM,UAAU,CAAC,aAA+B;AAC9C,SAAO,SAAS,KAAK,GAAG;AAC1B;AAcO,MAAM,aAAa,CACxB,OACA,OAAe,IACf,WAAqB,CAAC,GACtB,MAAM,oBAAI,IAAoB,GAC9B,UAAU,oBAAI,QAAQ,MACnB;AAEH,MAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC/C,WAAO;AAAA,EACT;AAGA,MAAI,QAAQ,IAAI,KAAK,GAAG;AACtB,WAAO;AAAA,EACT;AAGA,UAAQ,IAAI,KAAK;AAGjB,QAAM,KAAK,MAAM,KAAK;AAGtB,MAAI,IAAI;AACN,QAAI,IAAI,IAAI,QAAQ,QAAQ,CAAC;AAAA,EAC/B;AAGA,QAAM,UAAU,MAAM;AAGtB,MAAI,MAAM,SAAS,KAAK,OAAO,MAAM,SAAS,MAAM,UAAU;AAC5D,QAAI,IAAI,GAAG,OAAO,IAAI,MAAM,SAAS,CAAC,IAAI,QAAQ,QAAQ,CAAC;AAAA,EAC7D;AAGA,aAAW,OAAO,OAAO;AACvB,QAAI,OAAO,MAAM,GAAG,MAAM,YAAY,MAAM,GAAG,MAAM,MAAM;AACzD,iBAAW,MAAM,GAAG,GAAG,SAAS,CAAC,GAAG,UAAU,GAAG,GAAG,KAAK,OAAO;AAAA,IAClE;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": []
}
